/*
 * Copyright (c) 2014, alekstheod <email>
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *     * Redistributions of source code must retain the above copyright
 *     notice, this list of conditions and the following disclaimer.
 *     * Redistributions in binary form must reproduce the above copyright
 *     notice, this list of conditions and the following disclaimer in the
 *     documentation and/or other materials provided with the distribution.
 *     * Neither the name of the <organization> nor the
 *     names of its contributors may be used to endorse or promote products
 *     derived from this software without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY alekstheod <email> ''AS IS'' AND ANY
 * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
 * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED. IN NO EVENT SHALL alekstheod <email> BE LIABLE FOR ANY
 * DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
 * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
 * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
 * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
 * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 *
 */

#include "PerceptronTest.h"
#include <gtest/gtest.h>
#include <gmock/gmock.h>
#include <Utilities/GMockUtils.h>
/*
using ::testing::Return;
using ::testing::Ref;
using ::testing::_;
using ::testing::Mock;
using ::testing::InSequence;
PerceptronTest::PerceptronTest():m_inputsNumber(0), m_outputsNumber(0) {
}

PerceptronTest::~PerceptronTest() {
}

void PerceptronTest::SetUp() {
    m_inputsNumber  = 2;
    m_outputsNumber = 1;
    m_outputs.resize(1, 0.f);
    m_inputs.resize(2, 0.f);
}

void PerceptronTest::TearDown() {
    m_neurons.clear();
}

TEST_F(PerceptronTest, TestConstructor) {
    Perceptron perceptron( 2, 1 );
    auto layersNumber = std::distance ( perceptron.begin(), perceptron.end() );
    ASSERT_EQ( 1,  layersNumber);
    ASSERT_EQ( 2, (*perceptron.begin())->m_inputsNumber);
}

TEST_F(PerceptronTest, TestAddLayerOneAdditionalLayer) {
    const unsigned int inputsNumber = 2;
    Perceptron perceptron(inputsNumber, 2);

    typedef NeuralLayer::Neuron Neuron;
    std::vector<Neuron> neurons(1,NeuralLayer::Neuron(inputsNumber));
    Neuron& neuron = neurons[0];

    NeuralLayer::Mock& layer = *(**perceptron.begin());
    perceptron.addLayer(5);
    ASSERT_EQ(2, perceptron.size() );
    ASSERT_EQ(2, (*perceptron.begin())->m_neuronsNumber );
    ASSERT_EQ(2, (*perceptron.begin())->m_inputsNumber );
    ASSERT_EQ(5, (*(perceptron.begin()+1))->m_neuronsNumber );
    ASSERT_EQ(2, (*(perceptron.begin()+1))->m_inputsNumber );
    ASSERT_EQ(5, perceptron.getOutputLayer()->m_inputsNumber );
    ASSERT_EQ(2, perceptron.getOutputLayer()->m_neuronsNumber );
}

TEST_F(PerceptronTest, TestAddLayerTwoAdditionalLayers) {
    const unsigned int inputsNumber = 2;
    Perceptron perceptron(inputsNumber, 2);

    typedef NeuralLayer::Neuron Neuron;
    std::vector<Neuron> neurons(1,Neuron(inputsNumber));
    neurons.push_back(Neuron(5));

    Neuron& neuron = neurons[0];
    perceptron.addLayer(5);
    perceptron.addLayer(7);

    ASSERT_EQ(3, perceptron.size() );
    ASSERT_EQ(5, (*(perceptron.begin()+1))->m_neuronsNumber );
    ASSERT_EQ(2, (*(perceptron.begin()+1))->m_inputsNumber );

    ASSERT_EQ(7, (*(perceptron.begin()+2))->m_neuronsNumber );
    ASSERT_EQ(5, (*(perceptron.begin()+2))->m_inputsNumber );

    ASSERT_EQ(2, perceptron.getOutputLayer().size() );
    ASSERT_EQ(7, perceptron.getOutputLayer()->m_inputsNumber );
}

USING_SUPPORT_TEST_T_N(PerceptronTest, TestCalculateOutputsForOneLayerPerceptron, nn, Perceptron)
TEST_F(PerceptronTest, TestCalculateOutputsForOneLayerPerceptron) {
  m_inputsNumber = 2;
  m_outputsNumber = 1;
  Perceptron perceptron(m_inputsNumber, m_outputsNumber);
  perceptron.supportTest(*this);
  m_outputs.push_back(1.0);
  std::array< float, 1 > outputs = { 0 };
  perceptron.calculateOutputs(m_inputs.begin(), m_inputs.end(), outputs.begin() );
  ASSERT_EQ( m_outputs[0], outputs[0] );
}

SUPPORT_TEST_T(PerceptronTest, TestCalculateOutputsForOneLayerPerceptron, Perceptron){
  test.m_neurons = std::vector< Neuron >(1,Neuron(test.m_inputsNumber));
  
  InSequence dummy;
  EXPECT_CALL( **m_layers[0],  setInput(0, test.m_inputs[0] ) ).Times(1);
  EXPECT_CALL( **m_layers[0],  setInput(1, test.m_inputs[1] ) ).Times(1);
  EXPECT_CALL( **m_layers[0],  calculateOutputs( Ref(*m_outputLayer) ) ).Times(1);
  EXPECT_CALL( **m_outputLayer, calculateOutputs() ).Times(1);
  EXPECT_CALL( **m_outputLayer, end() ).WillOnce( Return(test.m_neurons.end()) );
  EXPECT_CALL( **m_outputLayer, begin() ).WillOnce( Return(test.m_neurons.begin()) );
  EXPECT_CALL( **test.m_neurons[0],  getOutput() ).Times(1).WillRepeatedly(Return(test.m_outputs[0]) );
}


USING_SUPPORT_TEST_T_N(PerceptronTest, TestCalculateOutputsForTwoLayersPerceptron, nn, Perceptron)
TEST_F(PerceptronTest, TestCalculateOutputsForTwoLayersPerceptron)
{
    Perceptron perceptron(m_inputsNumber, m_outputsNumber);
    perceptron.supportTest(*this);
    std::array< float, 1 > outputs = { 0 };
    perceptron.calculateOutputs(m_inputs.begin(), m_inputs.end(), outputs.begin() );
    ASSERT_EQ( 1.f, outputs[0] );
}

SUPPORT_TEST_T(PerceptronTest, TestCalculateOutputsForTwoLayersPerceptron, Perceptron)
{
    const unsigned int inputsNumber = 2;
    const unsigned int outputsNumber = 1;
    m_layers[0] = Perceptron::NeuralLayer(2, 5);
    m_layers.push_back(Perceptron::NeuralLayer(5, 2) );
    m_outputLayer = Perceptron::OutputLayer(2, 1);
    test.m_neurons = std::vector< Neuron >(5,Neuron(inputsNumber));

    InSequence dummy;
    EXPECT_CALL( **m_layers[0],  setInput(0, test.m_inputs[0] ) ).Times(1);
    EXPECT_CALL( **m_layers[0],  setInput(1, test.m_inputs[1] ) ).Times(1);
    EXPECT_CALL( **m_layers[0],  calculateOutputs( Ref(*m_layers[1]) ) ).Times(1);
    EXPECT_CALL( **m_layers[1],  calculateOutputs( Ref(*m_outputLayer)  ) ).Times(1);
    EXPECT_CALL( **m_outputLayer,  calculateOutputs() ).Times(1);
    EXPECT_CALL( **m_outputLayer,  end() ).Times(1).WillOnce(Return(test.m_neurons.begin()+1) );
    EXPECT_CALL( **m_outputLayer,  begin() ).Times(1).WillOnce(Return(test.m_neurons.begin()) );
    EXPECT_CALL( **test.m_neurons[0],   getOutput() ).Times(1).WillOnce(Return( 1.f ) );
}
*/